# Agent Communication & Coordination Protocols

> Research for Masterplan — How agents talk to each other, coordinate work, and avoid stepping on each other's toes.

## 1. The Problem Space

When you have multiple AI agents that need to collaborate, three fundamental challenges emerge:

1. **Discovery** — How does Agent A find Agent B and know what it can do?
2. **Communication** — What protocol/format do they use to exchange messages?
3. **Coordination** — How do they divide work, avoid conflicts, and handle failures?

These map roughly to the same problems distributed systems have solved for decades (DNS/service discovery, RPC/messaging, consensus/locking) — but with the added wrinkle that agents are non-deterministic, opaque, and may be built by entirely different vendors.

---

## 2. Google's A2A (Agent-to-Agent) Protocol

**Status:** Release Candidate v1.0 (as of early 2026), open source under Linux Foundation (Apache 2.0).

### What It Is

A2A is an **open interoperability standard** for agent-to-agent communication. It's designed for the case where agents are opaque to each other — they don't share internal state, memory, or tool implementations. Think of it as HTTP for agents.

### Architecture (Three Layers)

| Layer | Purpose | Examples |
|-------|---------|---------|
| **Data Model** | Core data structures (protobuf-defined) | Task, Message, Part, Artifact, AgentCard, Extension |
| **Operations** | Abstract capabilities agents must support | SendMessage, StreamMessage, GetTask, ListTasks, CancelTask, GetAgentCard |
| **Protocol Bindings** | Concrete wire formats | JSON-RPC 2.0 over HTTP(S), gRPC, REST |

### Key Concepts

- **Agent Card** — JSON metadata document published by an agent describing its identity, capabilities, skills, endpoint URL, and auth requirements. This is the discovery mechanism — agents find each other by fetching Agent Cards.
- **Task** — The fundamental unit of work. Stateful, identified by unique ID, progresses through a lifecycle. Tasks can be long-running.
- **Message** — A communication turn with a role ("user" or "agent") containing one or more Parts.
- **Part** — Smallest content unit: text, file reference, or structured JSON data.
- **Artifact** — Output generated by an agent (documents, images, structured data).
- **Context** — Optional server-generated ID to group related tasks/messages.

### Interaction Modes

1. **Synchronous** — Request/response (simple tasks)
2. **Streaming** — Server-Sent Events for real-time incremental updates
3. **Async Push** — Webhook-based notifications for long-running tasks

### Why It Matters

- **Vendor-agnostic** — Any framework can implement it (SDKs exist for Python, Go, JS, Java, .NET)
- **Opacity-preserving** — Agents collaborate without exposing internals
- **Enterprise-ready** — Built-in auth, tracing, security considerations
- **Protobuf-canonical** — Single source of truth for the data model, bindings are generated

### Limitations

- Still maturing (RC v1.0) — ecosystem adoption is early
- No built-in coordination/consensus — it's a communication protocol, not an orchestration framework
- Discovery is currently "fetch the Agent Card at a known URL" — no global registry yet

---

## 3. OpenAI Swarm → Agents SDK

### Swarm (Historical, Educational)

OpenAI's Swarm was an **experimental/educational framework** exploring lightweight multi-agent orchestration. Now deprecated in favour of the OpenAI Agents SDK.

**Core primitives (just two!):**
1. **Agent** — Instructions + tools + optional handoff targets
2. **Handoff** — An agent can transfer the conversation to another agent

**Key design decisions:**
- **Stateless** — No state stored between `client.run()` calls (like Chat Completions)
- **Client-side** — Runs entirely on the client, no server-side agent infrastructure
- **Loop-based** — `run()` loops: call LLM → execute tools → check for handoff → repeat until final output

### OpenAI Agents SDK (Production)

The production evolution of Swarm, actively maintained. Adds:

- **Guardrails** — Input/output validation and safety checks
- **Sessions** — Automatic conversation history management across runs
- **Tracing** — Built-in run tracking with extensible exporters (Logfire, AgentOps, Braintrust, etc.)
- **Structured output** — Agents can declare output types, loop runs until type is satisfied
- **Provider-agnostic** — Works with OpenAI APIs + 100+ other LLMs

### The Handoff Pattern

This is the key coordination mechanism in the Swarm/Agents lineage:

```python
triage_agent = Agent(
    name="Triage",
    instructions="Route to the right specialist",
    handoffs=[billing_agent, technical_agent, sales_agent],
)
```

The LLM decides when to hand off and to whom. It's essentially **LLM-driven routing** — the model itself acts as the coordinator. Simple, elegant, but trusts the LLM to make good routing decisions.

---

## 4. Communication Patterns

### 4.1 Direct Message Passing

**How it works:** Agent A sends a structured message directly to Agent B and waits for a response.

**Protocols:**
- HTTP request/response (A2A uses this)
- JSON-RPC (A2A's default binding)
- gRPC (A2A supports this too, better for streaming)
- WebSockets (persistent bidirectional connection)

**Pros:** Simple, easy to reason about, familiar
**Cons:** Tight coupling, caller must know who to call, doesn't scale to many-to-many

### 4.2 Event-Driven / Pub-Sub

**How it works:** Agents publish events to topics; other agents subscribe to topics they care about. No direct coupling.

**Infrastructure:** Message brokers (Kafka, RabbitMQ, Redis Streams, NATS, cloud pub/sub)

**Example flow:**
```
ResearchAgent publishes → "research.complete" topic
  ├── WriterAgent subscribes → picks up results, starts writing
  ├── FactCheckAgent subscribes → validates claims
  └── SummaryAgent subscribes → generates executive summary
```

**Pros:**
- Loose coupling — publishers don't know subscribers
- Fan-out — one event triggers multiple agents
- Resilience — broker handles buffering, retry, ordering
- Natural for reactive workflows

**Cons:**
- Harder to trace end-to-end (need correlation IDs)
- Eventual consistency — no guaranteed ordering across topics
- More infrastructure to manage

### 4.3 Shared State / Blackboard Pattern

**How it works:** Agents read from and write to a shared data store. They react to changes in the shared state rather than receiving explicit messages.

**Classic AI pattern:** The "blackboard" architecture from 1970s/80s AI — multiple knowledge sources contribute to a shared blackboard, a controller decides who acts next.

**Modern implementations:**
- Shared database/document (e.g., agents editing a shared JSON doc)
- Redis/etcd as shared state
- CRDTs for conflict-free concurrent edits
- Git-like version control for agent outputs

**Pros:** Simple mental model, natural for collaborative editing
**Cons:** Coordination complexity, potential for conflicts, need locking or merge strategies

### 4.4 Orchestrator Pattern

**How it works:** A central orchestrator agent manages workflow, delegates tasks to specialist agents, aggregates results.

```
Orchestrator
  ├── assigns task → Agent A
  ├── assigns task → Agent B
  ├── waits for both
  └── combines results → final output
```

**Pros:** Clear control flow, easy to debug, single point of coordination
**Cons:** Single point of failure, bottleneck, orchestrator needs to understand all agents

### 4.5 Choreography (Peer-to-Peer)

**How it works:** No central coordinator. Agents follow protocols/rules and coordinate through local interactions (like Swarm handoffs).

**Pros:** No bottleneck, resilient, scales naturally
**Cons:** Harder to reason about globally, emergent behavior can surprise you

---

## 5. Coordination Challenges & Solutions

### 5.1 Preventing Conflicts

**Problem:** Two agents try to modify the same resource simultaneously.

**Solutions:**
| Strategy | How | Tradeoff |
|----------|-----|----------|
| **Pessimistic locking** | Acquire lock before modifying | Simple but blocks; risk of deadlock |
| **Optimistic concurrency** | Read version, write with version check, retry on conflict | Better throughput, more complex |
| **CRDTs** | Use conflict-free data types that merge automatically | No conflicts by design, limited data types |
| **Single-writer principle** | Each resource owned by exactly one agent | No conflicts, but limits parallelism |
| **Event sourcing** | Append-only log of changes, derive state | Full audit trail, replay capability |

**Recommendation for agent systems:** The **single-writer principle** is simplest and most robust. Assign clear ownership — Agent A owns resource X, if Agent B needs to change X, it requests via A. Combined with event sourcing for auditability.

### 5.2 Preventing Deadlocks

**Problem:** Agent A waits for Agent B which waits for Agent A.

**Solutions:**
- **Timeouts** — Always have a timeout on every inter-agent call. Non-negotiable.
- **Acyclic dependency graphs** — Design agent relationships as a DAG, never circular
- **Try-lock with backoff** — Don't block indefinitely; if you can't get the resource, back off and retry
- **Deadlock detection** — Monitor wait-for graphs, break cycles by aborting one participant

### 5.3 Preventing Duplicate Work

**Problem:** Two agents independently pick up the same task.

**Solutions:**
- **Idempotency keys** — Every task has a unique ID; processing is idempotent
- **Claim-based queuing** — Agent claims a task atomically (e.g., Redis `SETNX`, database `UPDATE ... WHERE status = 'pending'`)
- **Work-stealing queues** — Each agent has its own queue; idle agents steal from busy agents' queues
- **Deduplication at the broker** — Message broker deduplicates based on message ID

### 5.4 Failure Handling

**Problem:** An agent crashes mid-task.

**Solutions:**
- **Heartbeat/lease** — Agents renew leases on claimed tasks; if lease expires, task returns to pool
- **Saga pattern** — Break long workflows into steps with compensating actions for rollback
- **Checkpointing** — Agents save progress; on restart, resume from last checkpoint
- **Supervisor pattern** — A supervisor agent monitors workers, restarts or reassigns on failure (Erlang-style)

---

## 6. Practical Architecture Patterns

### Pattern 1: Hub-and-Spoke (Orchestrated)

```
         ┌─────────────┐
         │ Orchestrator │
         └──────┬──────┘
        ┌───────┼───────┐
        ▼       ▼       ▼
    [Agent A] [Agent B] [Agent C]
```

- Orchestrator holds the plan and delegates
- Agents report results back
- Good for: well-defined workflows, pipeline-style processing
- Used by: most current multi-agent frameworks (CrewAI, AutoGen)

### Pattern 2: Mesh (Peer-to-Peer via A2A)

```
    [Agent A] ◄──► [Agent B]
        ▲               ▲
        │               │
        ▼               ▼
    [Agent C] ◄──► [Agent D]
```

- Agents discover each other via Agent Cards
- Direct communication via A2A protocol
- Good for: heterogeneous ecosystems, cross-organization collaboration
- A2A is specifically designed for this

### Pattern 3: Event-Driven Pipeline

```
    [Agent A] → Event Bus → [Agent B] → Event Bus → [Agent C]
                    ↓                       ↓
               [Agent D]              [Agent E]
```

- Agents are loosely coupled via events
- Easy to add new agents without modifying existing ones
- Good for: reactive systems, fan-out processing, high scalability

### Pattern 4: Hierarchical (Supervisor Trees)

```
         [Supervisor]
         ├── [Team Lead A]
         │   ├── [Worker 1]
         │   └── [Worker 2]
         └── [Team Lead B]
             ├── [Worker 3]
             └── [Worker 4]
```

- Inspired by Erlang/OTP supervisor trees
- Each level manages failures at the level below
- Good for: robust production systems, complex organizations of agents

---

## 7. State of the Art (Early 2026)

| Framework/Protocol | Type | Communication Model | Maturity |
|-------------------|------|-------------------|----------|
| **A2A Protocol** | Open standard | HTTP/JSON-RPC, streaming, webhooks | RC v1.0 |
| **OpenAI Agents SDK** | Framework | In-process handoffs | Production |
| **LangGraph** | Framework | Graph-based state machine | Production |
| **CrewAI** | Framework | Orchestrated delegation | Production |
| **AutoGen** | Framework | Multi-agent conversations | Production |
| **MCP (Model Context Protocol)** | Standard | Tool/context exposure | Stable |

**Key distinction:** MCP is about connecting agents to **tools and data** (agent-to-tool). A2A is about connecting **agents to each other** (agent-to-agent). They're complementary, not competing.

---

## 8. Recommendations for Our System

### Communication Layer
1. **Use A2A for inter-agent communication** when agents are separate services/processes. It's the emerging standard with real industry momentum.
2. **Use in-process handoffs** (Swarm/Agents SDK pattern) when agents share a runtime. Don't over-engineer.
3. **Add an event bus** (Redis Streams or NATS) for decoupled async workflows and fan-out.

### Coordination Strategy
1. **Single-writer ownership** — Each resource/domain has one owning agent
2. **Timeouts everywhere** — Every inter-agent call has a timeout. Period.
3. **Idempotent task processing** — Every task has a unique ID, processing is retry-safe
4. **Supervisor hierarchy** — Agents organized in supervision trees for failure recovery

### Avoiding Common Pitfalls
- Don't let agents call each other in cycles — enforce DAG topology
- Don't share mutable state without a clear ownership model
- Don't assume synchronous communication — design for async first
- Don't skip correlation IDs — you'll need them for debugging distributed workflows
- Don't trust the LLM for critical coordination decisions — use deterministic logic for routing/locking/claiming

---

## 9. Key Takeaways

1. **A2A is the emerging standard** for cross-vendor agent interoperability. It's well-designed (HTTP, JSON-RPC, protobuf, streaming, webhooks) and has real backing.

2. **Handoffs are the simplest coordination primitive** — the Swarm pattern of "agent decides to transfer to another agent" is surprisingly powerful for many use cases.

3. **Distributed systems wisdom applies directly** — locking, idempotency, timeouts, sagas, supervision trees. None of this is new; it's just new to the AI agent crowd.

4. **Pick the right pattern for the job:**
   - Simple pipeline → Orchestrator
   - Cross-org/cross-vendor → A2A mesh
   - High-scale reactive → Event-driven
   - Fault-tolerant production → Supervisor trees

5. **MCP + A2A together** — MCP for agent-to-tool, A2A for agent-to-agent. This is likely the stack that wins.

---

*Researched 2026-02-08*
